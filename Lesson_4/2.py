"""
2. Написать два алгоритма нахождения i-го по счёту простого числа.
Без использования «Решета Эратосфена»;
Используя алгоритм «Решето Эратосфена»
"""

import timeit

# Способ 1. Используя решето Эратосфена

N = 1000
n = 10

a = [0] * N # создание массива с n количеством элементов и заполнение его
for i in range(N):
    a[i] = i

# сначала заполняем массив простыми числами, а потом находим по индексу нужный
def used_e(n):
    # вторым элементом является единица, которую не считают простым числом
    # забиваем ее нулем.
    a[1] = 0
    b = []
    m = 2  # замена на 0 начинается с 3-го элемента (первые два уже нули)
    while m < N:  # перебор всех элементов до заданного числа
        if a[m] != 0:  # если он не равен нулю, то
            b.append(a[m]) # вносим это простое число в массив b и проверяем длину массива (достигла ли искомого индекса)
            if len(b) > n:
                return b[n]
            j = m * 2  # увеличить в два раза (текущий элемент - простое число)
            while j < N:
                a[j] = 0  # заменить на 0
                j = j + m  # перейти в позицию на m больше
        m += 1


print(used_e(n))

print(timeit.timeit("used_e(n)", setup="from __main__ import used_e, n", number=10000))
# результат выполнения  = 1.210384

# Способ 2. Использование рекурсивной функции - перебор чисел и проверка на простое число

# проверка на простое число - перебор всех чисел до заданного числа с проверкой на делимость числа на них
def is_prime_num(num, div):
    if div == 1:
        return True
    if num % div == 0:
        return False
    else:
        return is_prime_num(num, div - 1)


def get_prime_num(n):
    if n == 2: # первое простое число
        return 1
    b = []
    for i in range(2, N):
        if is_prime_num(i, i-1):
            b.append(i)
        if len(b) > n:
            return b[n]


print(get_prime_num(n))
print(timeit.timeit("get_prime_num(n)", setup="from __main__ import get_prime_num, n", number=10000))
# результат выполнения  = 0.4496621999999997
